<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
     	<meta content="width=device-width, initial-scale=1.0" name="viewport">
     	<META NAME="ROBOTS" CONTENT="INDEX, FOLLOW">
     	<meta name="description" content="Brian Kirby's Website" >
      	<meta name="author" content="Brian Kirby">
      	<title>Brian Kirby</title>
				<script type="text/javascript"
			  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
			</script> <!--This adds mathjax-->
	</head>

<body>

<center>
<p style="margin:0px 0px 0px 0px">
<a href="./images/brian_picture.jpg"><img src="./images/brian_picture.jpg" border="0"></a><br>
<font size="6" >Brian Kirby, Ph.D.</font><br>
<a href="mailto:bkirby57@gmail.com"><font>bkirby57@gmail.com</font></a> </p>
<a href="./index.html">Home</a> | <a href="./notes.html">Notes</a> | <a href="./publications.html">Publications</a>
| <a href="https://www.github.com/briankirby">Github</a> | <a href="https://www.linkedin.com/in/bkirby1">LinkedIn</a>
</center>
<br>
<hr>
<br>
<!-- <script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script> -->
A density matrix \(\rho\) is usually defined as the average of quantum states given by:
$$
\rho = \sum_{i} p_{i} \vert \phi_{i} \rangle \langle \phi_{i} \vert,
$$
where \(\phi_{i}\) is a quantum state which the system could be in and \(p_{i}\) is the probability that the system is in that state (obviously the \(p_{i}\) sum to unity).
<br>
<br>
The above definition is convenient if you have a set of pure states you're starting with and want to construct \(\rho\).
<b>However, if you're just given a matrix, how can you tell if it's a valid density matrix? </b>
The answer to this is that a valid density matrix must fulfill the following two conditions:
$$
positive\;semidefinite \;\;\;\; \rho \ge 0,
$$
$$
normalized \;\;\;\; \text{Tr}(\rho) = 1,
$$
where \(\dagger\) represents the conjugate transpose and Tr the trace.
The first condition of positivity can be defined in several equivalent ways, but often the most convenient for quantum information is that it's both Hermitian and all of the eigenvalues of \(\rho\) are greater than or equal to zero.
<br>
<br>
It's easy then programmatically check if a given density matrix is valid given the above conditions.
For example, in Mathematica this can be accomplished with:
$$
\text{ValidDensityMatrix}[\text{$\rho $in$\_$}]\text{:=}\text{Module}[\{\rho \},\rho =\text{$\rho $in};\text{If}[\text{HermitianMatrixQ}[\rho ]\land \min (\text{Eigenvalues}[\rho ])\geq 0\land \text{Tr}[\rho ]=1,\text{True},\text{False}]];
$$
where the joint if statement checks the conditions above simultaneously.
In my experience, however, HermitianMatrixQ can sometimes demand precision higher than I need, and will say a matrix is not Hermitian when I want it to.
In these cases it can be useful to write your own check for this:
$$
\text{HermitianCheck}[\text{$\rho $in$\_$}]\text{:=}\text{Module}\left[\{\rho,\text{difference}\},\rho =\text{$\rho $in};\text{difference}=\text{Chop}[\rho -\text{ConjugateTranspose}[\rho]];\text{If}[\text{DeleteDuplicates}[\text{Flatten}[\text{difference}]][[1]]=0,\text{True},\text{False}]\right];
$$
This function checks the definition of a Hermitian matrix (that it's self-adjoint) by subtracting the conjugate transpose of a matrix from it self and checking to make sure the resulting matrix is all zeros.
The use of the Chop function seems to be what differentiates this from HermitianMatrixQ by setting numbers less than \(10^{-10}\) to zero.
The tolerance of Chop can be altered as needed.
I've also found that a similar problem can occur with precision when checking if the trace is unity, and a totally analogous solution of subtracting the two and chopping is useful here as well.
